//
// Generated by Bluespec Compiler (build cd96b228)
//
// On Sun May 30 13:43:01 IST 2021
//
//
// Ports:
// Name                         I/O  size props
// RDY_request_put                O     1 reg
// response_get                   O    16 reg
// RDY_response_get               O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// request_put                    I    20 reg
// EN_request_put                 I     1
// EN_response_get                I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkShifter_16_4(CLK,
		      RST_N,

		      request_put,
		      EN_request_put,
		      RDY_request_put,

		      EN_response_get,
		      response_get,
		      RDY_response_get);
  input  CLK;
  input  RST_N;

  // action method request_put
  input  [19 : 0] request_put;
  input  EN_request_put;
  output RDY_request_put;

  // actionvalue method response_get
  input  EN_response_get;
  output [15 : 0] response_get;
  output RDY_response_get;

  // signals for module outputs
  wire [15 : 0] response_get;
  wire RDY_request_put, RDY_response_get;

  // register m_it
  reg [1 : 0] m_it;
  reg [1 : 0] m_it$D_IN;
  wire m_it$EN;

  // register m_regX
  reg [15 : 0] m_regX;
  reg [15 : 0] m_regX$D_IN;
  wire m_regX$EN;

  // register m_regY
  reg [3 : 0] m_regY;
  wire [3 : 0] m_regY$D_IN;
  wire m_regY$EN;

  // ports of submodule m_in
  wire [19 : 0] m_in$D_IN, m_in$D_OUT;
  wire m_in$CLR, m_in$DEQ, m_in$EMPTY_N, m_in$ENQ, m_in$FULL_N;

  // ports of submodule m_out
  wire [15 : 0] m_out$D_IN, m_out$D_OUT;
  wire m_out$CLR, m_out$DEQ, m_out$EMPTY_N, m_out$ENQ, m_out$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_m_r0, WILL_FIRE_RL_m_r2;

  // inputs to muxes for submodule ports
  wire [15 : 0] MUX_m_regX$write_1__VAL_1,
		MUX_m_regX$write_1__VAL_2,
		MUX_m_regX$write_1__VAL_3;
  wire [1 : 0] MUX_m_it$write_1__VAL_1;
  wire MUX_m_it$write_1__SEL_1;

  // action method request_put
  assign RDY_request_put = m_in$FULL_N ;

  // actionvalue method response_get
  assign response_get = m_out$D_OUT ;
  assign RDY_response_get = m_out$EMPTY_N ;

  // submodule m_in
  FIFO2 #(.width(32'd20), .guarded(1'd1)) m_in(.RST(RST_N),
					       .CLK(CLK),
					       .D_IN(m_in$D_IN),
					       .ENQ(m_in$ENQ),
					       .DEQ(m_in$DEQ),
					       .CLR(m_in$CLR),
					       .D_OUT(m_in$D_OUT),
					       .FULL_N(m_in$FULL_N),
					       .EMPTY_N(m_in$EMPTY_N));

  // submodule m_out
  FIFO2 #(.width(32'd16), .guarded(1'd1)) m_out(.RST(RST_N),
						.CLK(CLK),
						.D_IN(m_out$D_IN),
						.ENQ(m_out$ENQ),
						.DEQ(m_out$DEQ),
						.CLR(m_out$CLR),
						.D_OUT(m_out$D_OUT),
						.FULL_N(m_out$FULL_N),
						.EMPTY_N(m_out$EMPTY_N));

  // rule RL_m_r0
  assign WILL_FIRE_RL_m_r0 = m_in$EMPTY_N && m_it == 2'd0 ;

  // rule RL_m_r2
  assign WILL_FIRE_RL_m_r2 = m_out$FULL_N && m_it == 2'd3 ;

  // inputs to muxes for submodule ports
  assign MUX_m_it$write_1__SEL_1 = m_it == 2'd2 || m_it == 2'd1 ;
  assign MUX_m_it$write_1__VAL_1 = m_it + 2'd1 ;
  assign MUX_m_regX$write_1__VAL_1 =
	     m_in$D_OUT[0] ? { m_in$D_OUT[18:4], 1'd0 } : m_in$D_OUT[19:4] ;
  assign MUX_m_regX$write_1__VAL_2 =
	     m_regY[1] ? { m_regX[13:0], 2'd0 } : m_regX ;
  assign MUX_m_regX$write_1__VAL_3 =
	     m_regY[2] ? { m_regX[11:0], 4'd0 } : m_regX ;

  // register m_it
  always@(MUX_m_it$write_1__SEL_1 or
	  MUX_m_it$write_1__VAL_1 or WILL_FIRE_RL_m_r2 or WILL_FIRE_RL_m_r0)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_m_it$write_1__SEL_1: m_it$D_IN = MUX_m_it$write_1__VAL_1;
      WILL_FIRE_RL_m_r2: m_it$D_IN = 2'd0;
      WILL_FIRE_RL_m_r0: m_it$D_IN = 2'd1;
      default: m_it$D_IN = 2'b10 /* unspecified value */ ;
    endcase
  end
  assign m_it$EN =
	     m_it == 2'd2 || m_it == 2'd1 || WILL_FIRE_RL_m_r2 ||
	     WILL_FIRE_RL_m_r0 ;

  // register m_regX
  always@(WILL_FIRE_RL_m_r0 or
	  MUX_m_regX$write_1__VAL_1 or
	  m_it or MUX_m_regX$write_1__VAL_2 or MUX_m_regX$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_m_r0: m_regX$D_IN = MUX_m_regX$write_1__VAL_1;
      m_it == 2'd1: m_regX$D_IN = MUX_m_regX$write_1__VAL_2;
      m_it == 2'd2: m_regX$D_IN = MUX_m_regX$write_1__VAL_3;
      default: m_regX$D_IN = 16'b1010101010101010 /* unspecified value */ ;
    endcase
  end
  assign m_regX$EN = WILL_FIRE_RL_m_r0 || m_it == 2'd1 || m_it == 2'd2 ;

  // register m_regY
  assign m_regY$D_IN = m_in$D_OUT[3:0] ;
  assign m_regY$EN = WILL_FIRE_RL_m_r0 ;

  // submodule m_in
  assign m_in$D_IN = request_put ;
  assign m_in$ENQ = EN_request_put ;
  assign m_in$DEQ = WILL_FIRE_RL_m_r0 ;
  assign m_in$CLR = 1'b0 ;

  // submodule m_out
  assign m_out$D_IN = m_regY[3] ? { m_regX[7:0], 8'd0 } : m_regX ;
  assign m_out$ENQ = WILL_FIRE_RL_m_r2 ;
  assign m_out$DEQ = EN_response_get ;
  assign m_out$CLR = 1'b0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        m_it <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (m_it$EN) m_it <= `BSV_ASSIGNMENT_DELAY m_it$D_IN;
      end
    if (m_regX$EN) m_regX <= `BSV_ASSIGNMENT_DELAY m_regX$D_IN;
    if (m_regY$EN) m_regY <= `BSV_ASSIGNMENT_DELAY m_regY$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    m_it = 2'h2;
    m_regX = 16'hAAAA;
    m_regY = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkShifter_16_4

